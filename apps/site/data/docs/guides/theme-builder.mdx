---
title: Creating Themes
description: Learn how to create a suite of themes for a Tamagui app.
---

<IntroParagraph>
  The new ThemeBuilder API allows for intuitively creating entire suites of themes for use
  with your design system on Tamagui with a simple syntax.
</IntroParagraph>

The Tamagui theme system is powerful, perhaps even too much for its own good. In the past, this complexity, combined with a relative lack of documentation, meant rolling your own theme suite was too much of a bother for most.

With version 1.37 Tamagui is releasing two new things: a "ThemeBuilder", exported as `createThemeBuilder` from `@tamagui/create-theme`, and a corresponding compile-time option `themeBuilder`.

The new ThemeBuilder makes it dramatically easier to generate a theme suite, while the `themeBuilder` option automates pre-generating themes and therefore avoids the cost of generating themes at runtime (as well as avoiding the extra bundle size of the `@tamagui/create-theme` package).

This guide goes into the concepts behind the ThemeBuilder, and ends with [a complete example](#complete-example).

<Aside>

### A bit of history

Tamagui has gone through many stages of "theme builders", ie functional APIs that let you generate a suite of themes. It means the current version is the result of a lot of iteration, and we think its led to a better outcome than if we had pushed out something quickly.

#### The first attempt

In the beginning there was simply a big imperative ball of goop that we recommended copy/pasting into your own app. We eventually put that behind a very ad-hoc and rigid single function that let you customize the base palettes, but nothing below that.

#### The second attempt

Our first attempt at formalizing the theme system came around version 1.2, with `@tamagui/create-theme`, which added a variety of concepts and helper functions. These basically let you generate your own full suite of themes from base palettes, as well as two new ideas, "templates" and "masks". Templates would simply pick values off a palette, where a mask could take a previous template and generate a new one based off of it.

These concepts were key in allowing for the new API to work. But still, it was a lot of work to put together a theme suite, and the resulting code was fairly verbose. We also never fully got around to documenting the system, as it was clear there were a variety of improvements to be made. So we still recommended just copy/pasting the themes config we built, and left users on their own.

#### The current attempt

With version 1.37 we're officially documenting and making a new ThemeBuilder first-class. It further builds off the work in `@tamagui/create-theme`, adding a layer above all the helper functions we previously created. Instead of having to import 6-7 different functions and compose them together yourself, you can import a single function, `createThemeBuilder`, which has a chained API that makes the resulting code far more elegant and readable.

It also has a variety of improvements - it makes it far easier to change your themes at any "level," while still sharing code at any other level. Further, it makes the idea of a palette and mask first class and named, which is key for us going forward with the [Studio](/studio). This means we can now have two-way sync with the Tamagui Studio - we can understand not just your themes, but the palettes, templates and masks you used the generate theme, but also, we can write back out to them if you change them within the visual affordances the Studio begets.

All in all this means that generating a complete suite of themes is now not only easy, but within reach of anyone, even designers! This is especially true as it's super easy to actually keep all the masks and templates the same, but just swap out the root level palettes. We expect an explosion of theme suites will bloom due to the big wins in ease of use enabled by the new `@tamagui/create-theme`.

</Aside>

---

### The Concepts

The way the new ThemeBuilder works is through three main concepts: a palette, a template, and a mask. It's worth understanding each and how they relate to a design system before getting your hands dirty.

But first - what is a theme?

#### Themes

A theme is simple, it's a static typed object with properties that map from name => color. The simplest example is this:

```tsx
{
  background: '#000',
  color: '#fff',
}
```

You can have as many values as you want in your themes, but what's important is that they share the same shape. Of course Tamagui themes [go rather deep with their support of sub-themes](/docs/intro/themes) that can be a subset of their parents'. But this is the only important thing to remember - themes all share the same shape, and (as of the current version) simply map to colors.

#### Palettes

The first layer of building a theme starts with a palette. All a palette is is a gradient within a single color, going from background to foreground:

<Blog.ThemeBuilder.ExamplePalette showLabels />

You can toggle dark mode in the top left of the site to see that in fact we have _two_ blue palettes: `light_blue` and `dark_blue`.

Here's a palette in code (the `dark_blue` one):

```tsx
const dark_blue = [
  'hsl(212, 35.0%, 9.2%)', // background
  'hsl(216, 50.0%, 11.8%)',
  'hsl(214, 59.4%, 15.3%)',
  'hsl(214, 65.8%, 17.9%)',
  'hsl(213, 71.2%, 20.2%)',
  'hsl(212, 77.4%, 23.1%)',
  'hsl(211, 85.1%, 27.4%)',
  'hsl(211, 89.7%, 34.1%)',
  'hsl(206, 100%, 50.0%)',
  'hsl(209, 100%, 60.6%)',
  'hsl(210, 100%, 66.1%)',
  'hsl(206, 98.0%, 95.8%)', // foreground
]
```

Palettes are great for a design system because they constrain your color choices to a consistent scale, and designs look better when they have consistency.

We can refer to a single color in the pallete based on their index:

<Blog.ThemeBuilder.ExamplePalette showIndices />

Where in this case 0 is the background, and 11 is the foreground.

Within Tamagui you can define your palettes to have as many of few colors as you like. You also technically don't _have_ to go from background to foreground, but we recommend it if only for being consistent (and for being able to share masks, which we'll get into shortly).

The offical `@tamagui/themes` theme suite that this very websites uses adds one more layer to this equation - the 0-index color is actually a "background transparent", leaving the 1st index as the actual background. Correspondingly, the 12th index is the strongest foreground, while the 13th is "foreground transparent".

#### Templates

The next level up from a palette is a template which are simple: they map a _name to an index of a palette_.

The name can be anything, and the index just refers to an offset of your palette.

In practice, it looks something like this:

```tsx
{
  background: 0,
  color: 12
}
```

The `tamagui` components have standardized on the following minimum theme:

```tsx
{
  background: string
  backgroundFocus: string
  backgroundHover: string
  backgroundPress: string
  backgroundStrong: string
  backgroundTransparent: string
  borderColor: string
  borderColorFocus: string
  borderColorHover: string
  borderColorPress: string
  color: string
  colorFocus: string
  colorHover: string
  colorPress: string
  colorTransparent: string
  placeholderColor: string
  shadowColor: string
  shadowColorFocus: string
  shadowColorHover: string
  shadowColorPress: string
}
```

The **why** behind templates will become apparent shortly, but first lets see **how** they are used. First, we can make a function that takes a palette and returns a theme:

```tsx
const createTheme = (palette: string[]) => ({
  background: palette[0],
  color: palette[12],
})
```

Which means if we call it with our pallete above, we get:

```tsx
createTheme(dark_blue)
// => {
//   background: 'hsl(212, 35.0%, 9.2%)',
//   color: 'hsl(206, 98.0%, 95.8%)'
// }
```

Now we can see how we can make this a generic function that accepts a template:

```tsx
const createTheme = (palette: string[], template: Record<string, number>) => ({
  background: palette[template.background],
  color: palette[template.color],
})

// now call createTheme(dark_blue, { background: 0, color: 12 })
// and we get the same output
```

So, why do this? Well, if we have more than one theme, we likely want to use the same template over and over. This generally makes sense when you match the lightness/saturation, but have a different hue. Even your base `light` and `dark` theme could share the same template.

The Tamagui site shares templates across all the color themes:

<Blog.ThemeBuilder.ExamplePalette theme="blue" />
<Blog.ThemeBuilder.ExamplePalette theme="red" />

In this case, we'd call `createTheme` with the same template, just changing out the red or blue palette:

```tsx
const colorTemplate = {
  background: 0,
  color: 12,
}

const blue_theme = createTheme(bluePalette, colorTemplate)
const red_theme = createTheme(redPalette, colorTemplate)
```

But it's not just this that makes templates useful, it also comes in handy when we want to modify a theme.

But in order to really understand that, we'll want to understand two final things: component themes, and masks.

#### Sub-themes

Lets take a quick detour. Tamagui themes can nest as many times as you want. This lets you do some amazing things.

We can set up a "subtle" sub-theme that turns anything inside it to have a lower contrast feel:

```tsx
const dark = {
  background: 'black',
  color: 'white',
}

const dark_subtle = {
  background: '#222', // dark gray
  color: '#ccc', // light gray
}

createTamagui({
  themes: {
    dark,
    dark_subtle,
  },
})
```

Note the `_subtle`. Underscores define a sub-theme. In your code you can now do this:

```tsx
import { Stack, Theme, styled } from '@tamagui/core'

const Square = styled(Stack, {
  background: '$background',
  width: 100,
  height: 100,
})

export default () => (
  <Theme name="dark">
    {/* this will have a background of black */}
    <Square />

    <Theme name="subtle">
      {/* this will have a background of #222 */}
      <Square />
    </Theme>
  </Theme>
)
```

Sub-themes are amazing - they avoid a trap that you can fall into when designing screens where you decide you want a different look for an area, so you go off and change all the color values. But then later on you want to share that area somewhere else, or perhaps you just change your mind and want to revert the feel. In those two cases you'd either be stuck refactoring the whole area to accept two or more sets of ternaries on every color value, or you'd have to manually go through and change all the values by hand.

Instead with a sub-theme, you can throw `<Theme name="subtle">` around the entire area without having to change any of the code inside of it at all.

Where it gets interesting is in a final feature of sub-themes: component themes.

Taking our example above, we can add a `name` to our `styled` call:

```tsx
import { Stack, styled } from '@tamagui/core'

const Square = styled(Stack, {
  name: 'Square',
  background: '$background',
  width: 100,
  height: 100,
})
```

And just like that, if we define a `_Square` sub-theme, any usage of `<Square />` will pick it up:

```tsx
// in your tamagui.config.ts:

const dark_Square = {
  background: 'darkblue',
}

createThemes({
  dark,
  dark_Square,
})

// in your app:

export default () => (
  <>
    <Theme name="dark">
      <Square /> {/* <-- this gets background: 'darkblue' */}
    </Theme>
  </>
)
```

This is how Tamagui solves themes. It gives you incredible power to re-skin the entire interface, without having to touch any code. It's not mandatory - you can always just go in and change the color values inline as you please. But it does mean that we (or your team) can ship default styles that are easy to override contextually at any point in the tree. Think of it as a super-power - if you don't use it, there's no downside, but if you do, you gain a pretty powerful new ability.

#### Masks

Ok, with the knowledge of sub-themes in hand, we're ready to see how masks bring the final piece of the puzzle together.
